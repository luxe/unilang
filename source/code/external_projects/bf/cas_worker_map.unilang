􏶞o􏶟
􏷲A mapping from blob digest to the workers where the blobs reside􏷱
􏷰This is used to identify the location of blobs within the shard
{blob digest -> set(worker1,worker2)}􏷯
􏷞build􏷝􏷞buildfarm􏷝􏷞instance􏷝􏷞shard􏷝

􏷤􏷣􏷦com.google.common.collect.LinkedHashMultimap􏷥
􏷤􏷣􏷦com.google.common.collect.Lists􏷥
􏷤􏷣􏷦com.google.common.collect.SetMultimap􏷥
􏷤􏷣􏷦java.util.List􏷥
􏷤􏷣􏷦build.buildfarm.common.redis.BalancedRedisQueue􏷥
􏷤􏷣􏷦build.buildfarm.common.redis.ProvisionedRedisQueue􏷥
􏷤􏷣􏷦redis.clients.jedis.JedisCluster􏷥
􏷤􏷣􏷦build.buildfarm.common.StringVisitor􏷥
􏷤􏷣􏷦java.util.Collections􏷥
􏷤􏷣􏷦java.util.regex.Matcher􏷥
􏷤􏷣􏷦java.util.regex.Pattern􏷥
􏷤􏷣􏷦build.buildfarm.v1test.QueueStatus􏷥
􏷤􏷣􏷦build.buildfarm.v1test.OperationQueueStatus􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Platform􏷥
􏷤􏷣􏷦java.lang.RuntimeException􏷥
􏷤􏷣􏷦java.util.ArrayList􏷥

􏷤􏷣􏷦org.redisson.Redisson􏷥
􏷤􏷣􏷦org.redisson.api.RSet􏷥
􏷤􏷣􏷦org.redisson.api.RSetMultimapCache􏷥
􏷤􏷣􏷦org.redisson.api.RedissonClient􏷥
􏷤􏷣􏷦org.redisson.config.Config􏷥
􏷤􏷣􏷦org.redisson.config.ClusterServersConfig􏷥
􏷤􏷣􏷦org.redisson.config.SingleServerConfig􏷥
􏷤􏷣􏷦io.netty.channel.nio.NioEventLoopGroup􏷥
􏷤􏷣􏷦io.netty.channel.epoll.EpollEventLoopGroup􏷥

􏲏􏲐􏲍build.buildfarm.instance.shard.JedisClusterFactory􏲎
􏲏􏲐􏲍build.buildfarm.common.redis.BalancedRedisQueue􏲎
􏲏􏲐􏲍build.buildfarm.common.redis.ProvisionedRedisQueue􏲎
􏲏􏲐􏲍build.buildfarm.common.StringVisitor􏲎
􏲏􏲐􏲍redis.clients.jedis.JedisCluster􏲎
􏲏􏲐􏲍org.junit.Test􏲎
􏲏􏲐􏲍java.util.List􏲎
􏲏􏲐􏲍java.util.ArrayList􏲎
􏲏􏲐􏲍org.junit.runner.RunWith􏲎
􏲏􏲐􏲍org.junit.runners.JUnit4􏲎
􏲏􏲐􏲍java.lang.Thread􏲎
􏲏􏲐􏲍java.util.concurrent.TimeUnit􏲎
􏲏􏲐􏲍java.lang.RuntimeException􏲎
􏲏􏲐􏲍java.io.IOException􏲎
􏲏􏲐􏲍java.util.function.Supplier􏲎
􏲏􏲐􏲍org.mockito.Mock􏲎
􏲏􏲐􏲍org.mockito.MockitoAnnotations􏲎
􏲏􏲐􏲍java.util.Arrays􏲎
􏲏i􏲐􏲍com.google.common.truth.Truth.assertThat􏲎
􏲏i􏲐􏲍org.mockito.Mockito.eq􏲎
􏲏i􏲐􏲍org.mockito.Mockito.mock􏲎
􏲏i􏲐􏲍org.mockito.Mockito.times􏲎
􏲏i􏲐􏲍org.mockito.Mockito.verify􏲎
􏲏i􏲐􏲍org.mockito.Mockito.when􏲎
􏲏i􏲐􏲍org.mockito.Mockito.any􏲎

􏶨the unique name of the map􏶧
􏶦the name is used in redis to store/access the data.
If two maps had the same name, they would be instances of the same underlying redis map􏶥
􏶘-􏶙􏶰c􏶯􏶮string􏶭􏶬name􏶫􏶪􏶩

􏶨whether or not the data should be cached in memory􏶧
􏶦we have this as an option for experimentation because profiling fully cached builds showed that a significant amount of time was spent waiting on jedis sockets
we think using a cached redis container may provide better performance under load􏶥
􏶘-􏶙􏶰c􏶯􏶮bool􏶭􏶬use memory cache􏶫􏶪􏶩

􏶨a memory cached redis container to serve as the cas lookup􏶧
􏶦this is only used if the object is configured to use a memory cache􏶥
􏶘-􏶙􏶰􏶯􏶮RSetMultimapCache<String, String>􏶭􏶬cacheMap􏶫􏶪􏶩

􏷐constructor􏷏
􏶠construct storage object under the assumption that all calls will go to redis (no caching)􏶡
􏷘+􏷗􏴅Constructor􏴆􏷒cas worker map􏷑
􏶜􏶝􏷆string􏷅􏷄name􏷃􏷀the global name of the map􏶿
􏶴
    this.name = name;
    
    //since no redisson client was given, we can assume this is false and skip constructing the cacheMap
    this.useMemoryCache = false;
􏶳

􏷐constructor􏷏
􏶠construct storage object with options on how the data will be stored/accessed􏶡
􏷘+􏷗􏴅Constructor􏴆􏷒cas worker map􏷑
􏶜􏶝􏷆RedissonClient􏷅􏷄client􏷃􏷀the redisson client used to initialize the cache container􏶿
􏶜􏶝􏷆string􏷅􏷄name􏷃􏷀the global name of the map􏶿
􏶜􏶝􏷆bool􏷅􏷄use memory cache􏷃􏷀whether some of the data should be stored in memory􏶿
􏶴
    this.name = name;
    this.useMemoryCache = useMemoryCache;
    
    if (useMemoryCache) {
        this.casLookup = client.getSetMultimapCache(name);
    }
􏶳


􏷐adjust blob mappings based on worker changes􏷏
􏶠adjustments are made based on added and removed workers.  Expirations are refreshed􏶡
􏷘+􏷗􏴅Transformer􏴆􏷒adjust blob locations􏷑
􏶜􏶝􏷆RedisClient􏷅􏷄client􏷃􏷀client used for interacting with redis when not using cacheMap􏶿
􏶜􏶝􏷆Digest􏷅􏷄blob digest􏷃􏷀the blob digest to adjust worker information from􏶿
􏶜􏶝􏷆Set<String>􏷅􏷄add workers􏷃􏷀workers to add􏶿
􏶜􏶝􏷆Set<String>􏷅􏷄remove workers􏷃􏷀workers to remove􏶿
􏶴
    if (useMemoryCache){
        adjustBlobLocationsRedisson(blobDigest,addWorkers,removeWorkers);
    }
    else{
        adjustBlobLocationsJedis(client,blobDigest,addWorkers,removeWorkers);
    }
􏶳

􏷐adjust blob mappings based on worker changes􏷏
􏶠adjustments are made based on added and removed workers.  Expirations are refreshed􏶡
􏷘-􏷗􏴅Transformer􏴆􏷒adjust blob locations redisson􏷑
􏶜􏶝􏷆Digest􏷅􏷄blob digest􏷃􏷀the blob digest to adjust worker information from􏶿
􏶜􏶝􏷆Set<String>􏷅􏷄add workers􏷃􏷀workers to add􏶿
􏶜􏶝􏷆Set<String>􏷅􏷄remove workers􏷃􏷀workers to remove􏶿
􏶴

    String key = DigestUtil.toString(blobDigest);
    cacheMap.putAll(key,addWorkers);
    for (String workerName : removeWorkers) {
       cacheMap.remove(key,workerName);
     }
     cacheMap.expireKey(key,config.getCasExpire(),TimeUnit.SECONDS);
􏶳

􏷐adjust blob mappings based on worker changes􏷏
􏶠adjustments are made based on added and removed workers.  Expirations are refreshed􏶡
􏷘-􏷗􏴅Transformer􏴆􏷒adjust blob locations jedis􏷑
􏶜􏶝􏷆RedisClient􏷅􏷄client􏷃􏷀client used for interacting with redis when not using cacheMap􏶿
􏶜􏶝􏷆Digest􏷅􏷄blob digest􏷃􏷀the blob digest to adjust worker information from􏶿
􏶜􏶝􏷆Set<String>􏷅􏷄add workers􏷃􏷀workers to add􏶿
􏶜􏶝􏷆Set<String>􏷅􏷄remove workers􏷃􏷀workers to remove􏶿
􏶴

    String key = casKey(blobDigest);
    client.run(
        jedis -> {
          for (String workerName : addWorkers) {
            jedis.sadd(key, workerName);
          }
          for (String workerName : removeWorkers) {
            jedis.srem(key, workerName);
          }
          jedis.expire(key, config.getCasExpire());
        });
􏶳





􏷐get the redis key name􏷏
􏶠this is to be used for the direct redis implementation􏶡
􏷘-􏷗􏴅Observer􏴆􏷒redis cas key􏷑
􏶜􏶝􏷆Digest􏷅􏷄blob digest􏷃􏷀the blob digest to be made part of the key􏶿
􏶾string􏶽􏶼key name􏶻􏶺the name of the key to use􏶹
􏶴
    return name + ":" + DigestUtil.toString(blobDigest);
􏶳

􏷐get the cacheMap key name􏷏
􏶠this is to be used for the cache map implementation􏶡
􏷘-􏷗􏴅Observer􏴆􏷒cache map cas key􏷑
􏶜􏶝􏷆Digest􏷅􏷄blob digest􏷃􏷀the blob digest to be made part of the key􏶿
􏶾string􏶽􏶼key name􏶻􏶺the name of the key to use􏶹
􏶴
    return DigestUtil.toString(blobDigest);
􏶳